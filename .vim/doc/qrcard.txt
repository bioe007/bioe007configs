 *qrcard.txt* quick and easy reference

 |Movement|
    |Basic-movement|
    |Complex-Movement|
 |Marks|
 |Tags|
 |Copying|
 |Insertion|
    |Insert-mode|
    |Advanced-insertion|
 |Deletion| 
 |Search|
    |Search-Patterns| 
    |Offsets-in-search-commands| 
    |Search-&-Substitution|
 |Key-mapping|
 |Visual-mode|
 |Scrolling-&-Windowing|
 |Execution-Commands|
 |Undoing,-Repeating-&-Registers|
 |Execution-Ranges|
 |Folding|
 |Miscellaneous|
 
============================================================
 *Movement*
============================================================
     *Basic-movement* 
 h l k j .. character left, right; line up, down
 b w ...... word/token left, right
 ge e ..... end of word/token left, right
 { } ...... beginning of previous, next paragraph
 ( ) ...... beginning of previous, next sentence
 0 ^ $ .... beginning, first, last character of line
 nG ngg ... line n, default the last, first
 n% ....... percentage n of the file (n must be provided)
 n| ....... column n of current line
 %  ....... match of next brace, bracket, comment, #define
 nH nL .... line n from start, bottom of window
 M ........ middle line of window                                                        
============================================================
     *Complex-Movement*
 - + .... line up, down on first non-blank character
 B W .... space-separated word left, right
 gE E ... end of space-separated word left, right
 n ...... down n − 1 line on first non-blank character
 g0 gm .. beginning, middle of screen line
 g^ g$ .. first, last character of screen line
 gk gj .. screen line up, down
 fc Fc .. next, previous occurence of character c
 tc Tc .. before next, previous occurence of c
 ; , .... repeat last fFtT, in opposite direction
 [[ ]] .. start of section backward, forward
 [] ][ .. end of section backward, forward
 [( ]) .. unclosed (, ) backward, forward
 [{ ]} .. unclosed {, } backward, forward
 [m ]m .. start of backward, forward Java method
 [# ]# .. unclosed #if, #else, #endif backward, forward
 [* ]* .. start, end of /* */ backward, forward
============================================================
 *Marks*
 mc ......... mark current position with mark c ∈ [a..Z]       
 ‘c ‘C ...... go to mark c in current, C in any file   
 ‘0..9 ...... go to last exit position  
 ‘‘ ‘" ...... go to position before jump, at last edit                   
 ‘[ ‘] ...... go to start, end of previously operated text                        
 :marks .... print the active marks list            
 :jumps .... print the jump list
 n^O ........ go to nth older position in jump list
 n^I ........ go to nth newer position in jump list
============================================================
 *Tags*
 :ta t ............ jump to tag t
 :nta ............. jump to nth newer tag in list 
 ^] CtrlT ......... jump to tag under cursor, previous tag
 :ts t<CR> ........ list matching tags & select for jump
 :tj t<CR> ........ jump to tag or select one if multiple 
 :tags<CR> ........ print tag list
 :npo<CR> ......... jump back from
 :n^T<CR> ......... jump back to nth older tag
 :tl<CR> .......... jump to last matching tag
 ^W} :pt t<CR> .... preview tag under cursor, tag t
 ^W] .............. split window and show tag under cursor
 ^Wz or :pc<CR> ... close tag preview window
============================================================
 *Copying*
 "x ...... use register x for next delete, yank, put
 :reg .... show the content of all registers
 :reg x .. show the content of registers x
 ym ...... yank the text of|Movement|command m
 yy Y .... yank current line into register
 p P ..... put register after, before cursor position
 ]p [p ... like p, P with indent adjusted
 gp gP ... like p, P leaving cursor after new text
============================================================
  *Insertion*
 i a ....... insert before, after cursor
 I A ....... insert at beginning, end of line
 gI ........ insert text in first column
 o O ....... open new line below|above current line
 rc ........ replace character under cursor with c
 grc ....... like r, but without affecting layout
 R ......... replace starting at the cursor
 gR......... like R, but without affecting layout
 cm ........ change text of|Movement|command m
 cc S ...... change current line
 C ......... change to the end of line
 s ......... change one character and insert
 ~ ......... switch case and advance cursor
 g~m ....... switch case of|Movement|command m
 gum gUm ... lowercase, uppercase text of|Movement|m 
 <m >m ..... shift left, right text of|Movement|m        
 n<< n>> ... shift n lines left, right
============================================================
     *Insert-mode*
 ^Vc ^Vn ........... insert char c, decimal value n 
 ^A ................ insert previously inserted text     
 ^@................. same as ^A and go to command mode                          
 ^Rx ^R^Rx ......... insert register x, literally              
 ^N CtrlP .......... text completion before, after cursor          
 ^W ................ delete word before cursor  
 ^U ................ delete all inserted character in line               
 ^D CtrlT .......... shift left, right one shift width     
 ^Kc1 c2 | c1<CR>c2. enter digraph {c1 , c2 }    
 ^Oc ............... execute c in temporary command mode                 
 ^XCtrlE ^X^Y ...... scroll up, down
 esc or ^[ ......... abandon edition → command mode                        
============================================================
     *Advanced-insertion*
 g?m .......... perform rot13 encoding on|Movement|m
 n^A nCtrlX ... +n, −n to number under cursor                  
 gqm .......... format lines of|Movement|m to fixed width
 :rce w ....... center lines in range r to width w
 :rle i ....... left align lines in range r with indent i
 :rri w ....... right align lines in range r to width w
 !mc .......... filter lines of|Movement|m through command c
 n!!c ......... filter n lines through command c
 :r!c ......... filter range r lines through command c
============================================================
  *Deletion* 
 x X ....... delete character under, before cursor
 dm ........ delete text of|Movement|command m
 dd D ...... delete current line, to the end of line
 J gJ ...... join current line with next, without space
 :rd<CR> ... delete range r lines
 :rdx<CR> .. delete range r lines into register x                          
============================================================
 *Search*
============================================================
     *Search-Patterns* 
 . ^ $ ...... any single character, start, end of line
 \< \> ...... start, end of word
 [c1-c2] .... single character in range c1 ..c2
 [^c1-c2] ... a single character not in range
 \i \k \I \K  an identifier, keyword; excl. digits
 \f \p \F \P  a file name, printable char.; excl. digits
 \s \S ...... a white space, a non-white space
 \e \t \r \b  <esc> , <tab> , <CR> , <DEL>
 \= * \+ .... match 0..1, 0..∞, 1..∞ of preceding atoms                
 \| ......... separate two branches (≡ or )                                    
 \( \) ...... group patterns into an atom                                       
 \& \n ...... the whole matched pattern, nth () group                            
 \u \l ...... next character made upper, lowercase              
 \c \C ...... ignore, match case on next pattern                                    
============================================================
     *Offsets-in-search-commands* 
 n or +n .... n line downward in column 1         
 -n ......... n line upward in column 1   
 e+n e-n .... n characters right, left to end of match                    
 s+n s-n .... n characters right, left to start of match                     
 ;sc ........ execute search command sc next              
============================================================
     *Search-&-Substitution*
 /s<CR> ?s<CR> ............. search forward, backward for s
 /s/o<CR> ?s?o<CR> ..... search fwd, bwd for s with offset o
 n or /<CR> ..................... repeat forward last search
 N or ?<CR> ................... repeat backward last search
 # * ... search backward, forward for word under cursor
 g# g* ............. same, but also find partial matches
 gd gD ... local, global definition of symbol under cursor
 :rs/f /t/x<CR> .............. substitute f by t in range r
           x : g(lobal), c(onfirm)
 :rs x<CR> ........... repeat substitution with new r & x
============================================================
 *Key-mapping*
 :map c e .. map c → e in normal & visual mode                        
 :map! c e .. map c → e in insert & cmd-line mode                         
 :unmap c :unmap! c<CR> .......... remove mapping c                     
 :mk f  ... write current mappings, settings... to file f                  
 :ab c e ................. add abbreviation for c → e       
 :ab c<CR> ............ show abbreviations starting with c          
 :una c<CR> ....................... remove abbreviation c 
============================================================
 *Visual-mode*
 v V ^v .. start|stop highlight characters, lines, block
 o ....... cursor position to start of highlighting
 gv ...... start highlighting on previous visual area
 aw as ap  select a word, a sentence, a paragraph
 ab aB ... select a block ( ), a block { }
============================================================
 *Scrolling-&-Windowing*
 ^E ^Y ........ scroll line up, down
 ^D ^U ........ scroll half a page up, down
 ^F ^B ........ scroll page up, down
 zt or z<CR> ..... set current line at top of window
 zz or z....... set current line at center of window
 zb or z- ..... set current line at bottom of window
 zh zl ........ scroll one character to the right, left
 zH zL ........ scroll half a screen to the right, left
 ^Ws or :split<CR> split window in two       
 ^Wn or :new<CR> . create new empty window              
 ^Wo or :on<CR> .. make current window one on screen                       
 ^Wj ^Wk ...... move to window below, above              
 ^Ww ^W^W...... move to window below, above (wrap)                         
============================================================
 *Execution-Commands*
 :e f .... edit file f , unless changes have been made
 :e! f ... edit file f always (by default reload current)
 :wn :wN . write file and edit next, previous one
 :n :N ... edit next, previous file in list
 :rw ..... write range r to current file
 :rw f ... write range r to file f
 :rw> .... append range r to file f
 :q :q! .. quit and confirm, quit and discard changes
 :wq :x ZZ write to current file and exit
 up down . recall commands starting with current                                  
 :r f .... insert content of file f below cursor                
 :r! c ... insert output of command c below cursor                        
 :args ... display the argument list       
 :rc a :rm a .......... copy, move range r below line a                    
============================================================
 *Undoing,-Repeating-&-Registers*
 u U .... undo last command, restore last changed line
 ^R...... repeat last changes, redo last undo
 n....... repeat last changes with count replaced by n
 qc qC .. record, append typed characters in register c
 q ...... stop recording
 @c ..... execute the content of register c
 @@ ..... repeat previous @ command
 :@c<CR> ... execute register c as an Ex command
 :rg/p/c<CR> execute Ex command c on range r
============================================================
 *Execution-Ranges*
 , ; ...... separates two lines numbers, set to first line
 n ........ an absolute line number n
 . $ ...... the current line, the last line in file
 % * ...... entire file, visual area
 ’t ....... position of mark t
 /p/ ?p? .. the next, previous line where p matches
============================================================
 *Folding*
 zfm ............ create fold of|Movement|m
 :rfo............ create fold for range r
 zd zE .......... delete fold at cursor, all in window
 zo zc zO zC .... open, close one fold; recursively
 [z ]z .......... move to start, end of current open fold
 zj zk .......... move down, up to start, end of next fold
 zv ............. open enough folds to see cursor line
 zr ............. reduce folding, foldlevel++
 zR ............. open all folds, max(foldlevel)
 zx ............. Update folds, re-apply 'foldlevel', 
============================================================
 *Miscellaneous*
 :sh<CR> :!c<CR> ... start shell, execute command c in shell
 K ................. lookup keyword under cursor with man
 :make<CR> ......... make, read errors and jump to first
 :cn<CR> :cp<CR> ... display the next, previous error
 :cl<CR> :cf<CR> ... list all errors, read errors from file
 ^L ^G ............. redraw screen, show filename and pos
 g^G ............... show cursor column, line, and char pos
 ga ................ show ASCII value of char under cursor
 gf................. open filename under cursor
 :redir>f <CR> ..... redirect output to file f
 :mkview [f ] ...... save view configuration [to file f ]
 :loadview [f ] .... load view configuration [from file f ]
 ^@ ^K ^ \ Fn ^Fn .. unmapped keys
============================================================
 vim:tw=60:wiw=60:ts=8:noet:ft=help:
